# Learning Litestar

A compact playground that demonstrates how to serve both classic HTTP routes and
GraphQL queries with [Litestar](https://litestar.dev) 2.x and
[Strawberry GraphQL](https://strawberry.rocks). The project keeps the footprint
deliberately small so you can focus on how the pieces fit together: a GraphQL
schema, Litestar dependency injection, and a minimal test suite.

## Highlights

- Litestar application factory in `src/app/__init__.py` that exposes:
  - `GET /` — a synchronous route that stays on the event loop.
  - `POST /graphql` — a Strawberry-powered GraphQL controller created with
    `make_graphql_controller`.
- Dependency-injected GraphQL `root_value` provided with Litestar's `Provide`
  helper so Strawberry receives a fully constructed `Query` instance each time.
- Tests built with `pytest` and `litestar.testing.TestClient` that exercise both
  HTTP and GraphQL flows.
- Tooling powered by `uv`, `ruff`, and `mypy` for repeatable local workflows.

## Project Layout

```
src/
  app/__init__.py      # Litestar app, HTTP route, Strawberry schema & controller
tests/
  test_app.py          # End-to-end tests for the HTTP and GraphQL endpoints
pyproject.toml         # Project metadata, Ruff & mypy configuration
uv.lock                # Reproducible dependency lock generated by uv
```

## Requirements

- Python 3.12 (the project targets `py312`).
- [uv](https://github.com/astral-sh/uv) 0.8+ for dependency management
  (recommended). If you prefer `pip`, create a virtual environment manually and
  install the dependencies with `pip install -e .` plus any tools you need.

## Getting Started

```bash
# Install dependencies (includes dev tools such as pytest, ruff, mypy)
uv sync --all-extras --dev

# Run the development server with auto-reload
uv run litestar run --app app:app --reload
```

The server listens on <http://127.0.0.1:8000/> by default.

## Available Endpoints

### HTTP

```
GET /
```

Example:

```bash
curl http://127.0.0.1:8000/
# => Hello, world!
```

### GraphQL

```
POST /graphql
```

You can query the schema with any GraphQL client or cURL:

```bash
curl -X POST http://127.0.0.1:8000/graphql \
  -H 'content-type: application/json' \
  -d '{"query": "query { hello }"}'

# => {"data":{"hello":"Hello World"}}
```

The schema lives in `Query`, and the controller is generated via
`make_graphql_controller`. Litestar's DI injects a fresh `Query` instance through
`Provide(Query, sync_to_thread=False)`, which keeps resolver execution on the
event loop without extra thread hops.

## Quality Checks

```bash
# Tests
uv run pytest

# Ruff linting (same flags used by CI)
uv run ruff check --select ALL . --fix --unsafe-fixes --preview --show-fixes

# Ruff formatting
uv run ruff format .

# Static typing
uv run mypy .
```

## Design Notes

- The GraphQL `Query` type stores its greeting on a `strawberry.Private` field,
  which keeps configuration server-side while exposing only the resolver in the
  schema.
- `sync_to_thread=False` is set both on the HTTP route and on the `Provide`
  wrapper for the GraphQL root value. Both operations are CPU-light and
  non-blocking, so remaining on the event loop avoids unnecessary thread
  scheduling and keeps the warning logs quiet.
- All configuration is centralized in `pyproject.toml`, including Ruff and
  mypy settings, to reduce dotfile sprawl.

## Next Steps

Ideas for extending the playground:

- Add mutations or subscriptions to the Strawberry schema.
- Introduce persistence (e.g., SQLModel or Piccolo) and showcase Litestar's DI
  for database sessions.
- Experiment with background tasks or websocket integrations from Litestar.
- Wire up a front-end (HTMX, React, etc.) and consume the GraphQL endpoint.

Enjoy exploring Litestar and Strawberry together!

## License

Distributed under the MIT License. See `LICENSE` for full text.
